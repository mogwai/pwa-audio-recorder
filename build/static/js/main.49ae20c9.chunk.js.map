{"version":3,"sources":["audio/encoder-wav-worker.js","audio/encoder-mp3-worker.js","audio/encoder-ogg-worker.js","audio/RecorderService.js","App.js","serviceWorker.js","index.js"],"names":["encoder_wav_worker","BYTES_PER_SAMPLE","recorded","this","onmessage","e","data","buffer","length","Uint8Array","i","index","sample","push","console","log","encode","sampleRate","bufferLength","wav","view","DataView","setUint32","setUint16","set","msg","postMessage","dump","close","encoder_mp3_worker","channels","kbps","mp3encoder","maxSamples","mp3Data","convertBuffer","arrayBuffer","Float32Array","out","Int16Array","input","output","s","Math","max","min","floatTo16BitPCM","opts","samplesMono","remaining","left","subarray","encodeBuffer","mp3buf","flush","importScripts","baseUrl","lamejs","Mp3Encoder","encoder_ogg_worker","quality","oggEncoder","oggData","blob","finish","OggVorbisEncoder","RecorderService","_this","Object","classCallCheck","startRecording","timeslice","state","navigator","mediaDevices","getUserMedia","audioCtx","AudioContext","micGainNode","createGain","outputGainNode","config","createDynamicsCompressorNode","dynamicsCompressorNode","createDynamicsCompressor","createAnalyserNode","analyserNode","createAnalyser","forceScriptProcessor","broadcastAudioProcessEvents","usingMediaRecorder","processorNode","createScriptProcessor","processorBufferSize","createMediaStreamDestination","destinationNode","destination","manualEncoderId","encoderWorker","createWorker","EncoderMp3","encoderMimeType","EncoderOgg","EncoderWav","addEventListener","event","Event","Blob","type","_onDataAvailable","userMediaConstraints","audio","echoCancellation","enableEchoCancellation","deviceId","then","stream","_startRecordingWithStream","catch","error","alert","message","setMicGain","newGain","micGain","gain","setValueAtTime","currentTime","micAudioStream","inputStreamNode","createMediaStreamSource","context","onGraphSetupWithInputStream","connect","nextNode","onaudioprocess","_onAudioProcess","mediaRecorder","MediaRecorder","evt","_onError","start","slicing","setInterval","em","dispatchEvent","CustomEvent","detail","inputBuffer","outputBuffer","getChannelData","stopRecording","stop","clearInterval","chunks","chunkType","blobUrl","URL","createObjectURL","recording","ts","Date","getTime","mimeType","size","disconnect","stopTracksAndCloseCtxWhenFinished","getTracks","forEach","track","window","webkitAudioContext","document","createDocumentFragment","fn","js","toString","replace","Worker","App","url","recordings","inputRef","React","createRef","numAudioSamples","recorderSrvc","setState","isRecording","onAudioProcess","channel","numberOfChannels","inputData","outputData","addNoise","random","onNewRecording","newR","getResponse","onChangeURL","current","value","_callee","formData","res","regenerator_default","a","wrap","_context","prev","next","FormData","append","axios","post","headers","Content-Type","sent","t0","find","x","responseData","_this2","_this$state","action","actionText","react_default","createElement","className","ref","onChange","onClick","map","key","src","controls","Component","isLocalhost","Boolean","location","hostname","match","registerValidSW","swUrl","serviceWorker","register","registration","onupdatefound","installingWorker","installing","onstatechange","controller","onUpdate","onSuccess","ReactDOM","render","src_App_0","getElementById","process","href","origin","concat","fetch","response","contentType","get","status","indexOf","ready","unregister","reload","checkValidServiceWorker"],"mappings":"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","file":"static/js/main.49ae20c9.chunk.js","sourcesContent":["export default function () {\n// Parts copied from https://github.com/chris-rudmin/Recorderjs\n  let BYTES_PER_SAMPLE = 2\n  let recorded = []\n\n  function encode (buffer) {\n    let length = buffer.length\n    let data = new Uint8Array(length * BYTES_PER_SAMPLE)\n    for (let i = 0; i < length; i++) {\n      let index = i * BYTES_PER_SAMPLE\n      let sample = buffer[i]\n      if (sample > 1) {\n        sample = 1\n      }\n      else if (sample < -1) {\n        sample = -1\n      }\n      sample = sample * 32768\n      data[index] = sample\n      data[index + 1] = sample >> 8\n    }\n    recorded.push(data)\n    console.log(data)\n  }\n\n  function dump (sampleRate) {\n    let bufferLength = recorded.length ? recorded[0].length : 0\n    let length = recorded.length * bufferLength\n    let wav = new Uint8Array(44 + length)\n\n    let view = new DataView(wav.buffer)\n\n    // RIFF identifier 'RIFF'\n    view.setUint32(0, 1380533830, false)\n    // file length minus RIFF identifier length and file description length\n    view.setUint32(4, 36 + length, true)\n    // RIFF type 'WAVE'\n    view.setUint32(8, 1463899717, false)\n    // format chunk identifier 'fmt '\n    view.setUint32(12, 1718449184, false)\n    // format chunk length\n    view.setUint32(16, 16, true)\n    // sample format (raw)\n    view.setUint16(20, 1, true)\n    // channel count\n    view.setUint16(22, 1, true)\n    // sample rate\n    view.setUint32(24, sampleRate, true)\n    // byte rate (sample rate * block align)\n    view.setUint32(28, sampleRate * BYTES_PER_SAMPLE, true)\n    // block align (channel count * bytes per sample)\n    view.setUint16(32, BYTES_PER_SAMPLE, true)\n    // bits per sample\n    view.setUint16(34, 8 * BYTES_PER_SAMPLE, true)\n    // data chunk identifier 'data'\n    view.setUint32(36, 1684108385, false)\n    // data chunk length\n    view.setUint32(40, length, true)\n\n    for (var i = 0; i < recorded.length; i++) {\n      wav.set(recorded[i], i * bufferLength + 44)\n    }\n\n    recorded = []\n    let msg = [wav.buffer]\n    postMessage(msg, [msg[0]])\n  }\n\n  this.onmessage = function (e) {\n    if (e.data[0] === 'encode') {\n      encode(e.data[1])\n    }\n    else if (e.data[0] === 'dump') {\n      dump(e.data[1])\n    }\n    else if (e.data[0] === 'close') {\n      this.close()\n    }\n  }\n}\n","// import 'babel-polyfill'\n// import lamejs from 'lamejs'\n\nexport default function () {\n  // Note that relative paths don't work when loaded as a blob\n  // https://stackoverflow.com/questions/22172426/using-importsscripts-within-blob-in-a-karma-environment\n  // importScripts('https://localhost:8443/workers/encoders/lame.js') // eslint-disable-line\n\n  let channels = 1 // 1 for mono or 2 for stereo\n  // let sampleRate = 44100 // 44.1khz (normal mp3 samplerate)\n  let kbps = 128 // encode 128kbps mp3\n\n  let mp3encoder = null\n\n  const maxSamples = 1152\n\n  var mp3Data = [] // array of Uint8Array\n\n  function init (opts) {\n    /* global lamejs */\n    importScripts(opts.baseUrl + '/workers/encoders/lame.min.js'); // eslint-disable-line\n    mp3encoder = new lamejs.Mp3Encoder(channels, opts.sampleRate, kbps)\n  }\n\n  function floatTo16BitPCM (input, output) {\n    for (var i = 0; i < input.length; i++) {\n      var s = Math.max(-1, Math.min(1, input[i]))\n      output[i] = (s < 0 ? s * 0x8000 : s * 0x7FFF)\n    }\n  }\n\n  function convertBuffer (arrayBuffer) {\n    var data = new Float32Array(arrayBuffer)\n    var out = new Int16Array(arrayBuffer.length)\n    floatTo16BitPCM(data, out)\n    return out\n  }\n\n  function encode (arrayBuffer) {\n    let samplesMono = convertBuffer(arrayBuffer)\n    let remaining = samplesMono.length\n    for (let i = 0; remaining >= 0; i += maxSamples) {\n      var left = samplesMono.subarray(i, i + maxSamples)\n      var data = mp3encoder.encodeBuffer(left)\n      mp3Data.push(data)\n      remaining -= maxSamples\n    }\n\n    // var mp3buf = mp3encoder.encodeBuffer(buffer)\n    // if (mp3buf.length > 0) {\n    //   mp3Data.push(mp3buf)\n    // }\n  }\n\n  function dump () {\n    var mp3buf = mp3encoder.flush()\n    if (mp3buf.length > 0) {\n      mp3Data.push(mp3buf)\n    }\n\n    // Probably results in native memory copy\n    postMessage(mp3Data)\n\n    // Would like to do this, but not possible because mp3Data is generic array of Uint8Array, and generic\n    // arrays are not transferrable types.\n    // postMessage(mp3Data, [mp3Data])\n\n    // This might help if/when ever become available again\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer/transfer\n\n    // For now, though, we have not other option except to build a complete copy in javascript. This means\n    // we temporarily require twice the memory of whatever was recorded.\n\n    mp3Data = []\n  }\n\n  onmessage = function (e) {\n    if (e.data[0] === 'encode') {\n      encode(e.data[1])\n    }\n    else if (e.data[0] === 'dump') {\n      dump(e.data[1])\n    }\n    else if (e.data[0] === 'init') {\n      init(e.data[1])\n    }\n    else if (e.data[0] === 'close') {\n      this.close()\n    }\n  }\n}\n","export default function () {\n  let channels = 1\n  let quality = 0.4\n\n  let oggEncoder = null\n\n  let oggData = []\n\n  function init (opts) {\n    /* global OggVorbisEncoder */\n\n    // Possibly required for loading min version, but couldn't get min version to work. Not sure why.\n    // self.OggVorbisEncoderConfig = {\n    //   memoryInitializerPrefixURL: opts.baseUrl + '/workers/encoders/'\n    // }\n\n    // Unable to load min version. Not sure why.  Error in firefox is \"The URI is malformed\". Guessing related to the .mem.\n    importScripts(opts.baseUrl + '/workers/encoders/OggVorbisEncoder.js'); // eslint-disable-line\n    oggEncoder = new OggVorbisEncoder(opts.sampleRate, channels, quality)\n  }\n\n  function encode (arrayBuffer) {\n    var data = oggEncoder.encode([arrayBuffer])\n    oggData.push(data)\n  }\n\n  function dump () {\n    let blob = oggEncoder.finish('audio/ogg')\n\n    // this works, but likely results in native memory copy\n    postMessage(blob)\n\n    // Looking at source of OggVorbisEncoder, I think it would be easy to change to allow transferring of the\n    // raw buffer instead.\n\n    // this does not work, I presume because blobs aren't transferrable\n    // postMessage(blob, [blob])\n\n    oggData = []\n  }\n\n  onmessage = function (e) {\n    if (e.data[0] === 'encode') {\n      encode(e.data[1])\n    }\n    else if (e.data[0] === 'dump') {\n      dump(e.data[1])\n    }\n    else if (e.data[0] === 'init') {\n      init(e.data[1])\n    }\n    else if (e.data[0] === 'close') {\n      this.close()\n    }\n  }\n}\n","/* Copyright (c) 2019 Josh Sanderson */\nimport EncoderWav from \"./encoder-wav-worker\";\nimport EncoderMp3 from \"./encoder-mp3-worker\";\nimport EncoderOgg from \"./encoder-ogg-worker\";\n\nexport default class RecorderService {\n  constructor(baseUrl) {\n    this.baseUrl = baseUrl;\n\n    window.AudioContext = window.AudioContext || window.webkitAudioContext;\n\n    this.em = document.createDocumentFragment();\n\n    this.state = \"inactive\";\n\n    this.chunks = [];\n    this.chunkType = \"\";\n\n    this.encoderMimeType = \"audio/wav\";\n\n    this.config = {\n      broadcastAudioProcessEvents: false,\n      createAnalyserNode: false,\n      createDynamicsCompressorNode: false,\n      forceScriptProcessor: false,\n      manualEncoderId: \"wav\",\n      micGain: 1.0,\n      processorBufferSize: 2048,\n      stopTracksAndCloseCtxWhenFinished: true,\n      usingMediaRecorder: typeof window.MediaRecorder !== \"undefined\",\n      enableEchoCancellation: true\n    };\n  }\n\n  createWorker(fn) {\n    var js = fn\n      .toString()\n      .replace(/^function\\s*\\(\\)\\s*{/, \"\")\n      .replace(/}$/, \"\");\n    var blob = new Blob([js]);\n    return new Worker(URL.createObjectURL(blob));\n  }\n\n  startRecording = timeslice => {\n    if (this.state !== \"inactive\") {\n      return;\n    }\n\n    // This is the case on ios/chrome, when clicking links from within ios/slack (sometimes), etc.\n    if (\n      !navigator ||\n      !navigator.mediaDevices ||\n      !navigator.mediaDevices.getUserMedia\n    ) {\n      alert(\"Missing support for navigator.mediaDevices.getUserMedia\"); // temp: helps when testing for strange issues on ios/safari\n      return;\n    }\n\n    this.audioCtx = new AudioContext();\n    this.micGainNode = this.audioCtx.createGain();\n    this.outputGainNode = this.audioCtx.createGain();\n\n    if (this.config.createDynamicsCompressorNode) {\n      this.dynamicsCompressorNode = this.audioCtx.createDynamicsCompressor();\n    }\n\n    if (this.config.createAnalyserNode) {\n      this.analyserNode = this.audioCtx.createAnalyser();\n    }\n\n    // If not using MediaRecorder(i.e. safari and edge), then a script processor is required. It's optional\n    // on browsers using MediaRecorder and is only useful if wanting to do custom analysis or manipulation of\n    // recorded audio data.\n    if (\n      this.config.forceScriptProcessor ||\n      this.config.broadcastAudioProcessEvents ||\n      !this.config.usingMediaRecorder\n    ) {\n      this.processorNode = this.audioCtx.createScriptProcessor(\n        this.config.processorBufferSize,\n        1,\n        1\n      ); // TODO: Get the number of channels from mic\n    }\n\n    // Create stream destination on chrome/firefox because, AFAICT, we have no other way of feeding audio graph output\n    // in to MediaRecorderSafari/Edge don't have this method as of 2018-04.\n    if (this.audioCtx.createMediaStreamDestination) {\n      this.destinationNode = this.audioCtx.createMediaStreamDestination();\n    } else {\n      this.destinationNode = this.audioCtx.destination;\n    }\n\n    // Create web worker for doing the encoding\n    if (!this.config.usingMediaRecorder) {\n      if (this.config.manualEncoderId === \"mp3\") {\n        // This also works and avoids weirdness imports with workers\n        // this.encoderWorker = new Worker(BASE_URL + '/workers/encoder-ogg-worker.js')\n        this.encoderWorker = this.createWorker(EncoderMp3);\n        this.encoderWorker.postMessage([\n          \"init\",\n          { baseUrl: this.baseUrl, sampleRate: this.audioCtx.sampleRate }\n        ]);\n        this.encoderMimeType = \"audio/mpeg\";\n      } else if (this.config.manualEncoderId === \"ogg\") {\n        this.encoderWorker = this.createWorker(EncoderOgg);\n        this.encoderWorker.postMessage([\n          \"init\",\n          { baseUrl: this.baseUrl, sampleRate: this.audioCtx.sampleRate }\n        ]);\n        this.encoderMimeType = \"audio/ogg\";\n      } else {\n        this.encoderWorker = this.createWorker(EncoderWav);\n        this.encoderMimeType = \"audio/wav\";\n      }\n      this.encoderWorker.addEventListener(\"message\", e => {\n        let event = new Event(\"dataavailable\");\n        if (this.config.manualEncoderId === \"ogg\") {\n          event.data = e.data;\n        } else {\n          event.data = new Blob(e.data, { type: this.encoderMimeType });\n        }\n        this._onDataAvailable(event);\n      });\n    }\n\n    // Setup media constraints\n    const userMediaConstraints = {\n      audio: {\n        echoCancellation: this.config.enableEchoCancellation\n      }\n    };\n    if (this.config.deviceId) {\n      userMediaConstraints.audio.deviceId = this.config.deviceId;\n    }\n\n    // This will prompt user for permission if needed\n    return navigator.mediaDevices\n      .getUserMedia(userMediaConstraints)\n      .then(stream => {\n        this._startRecordingWithStream(stream, timeslice);\n      })\n      .catch(error => {\n        alert(\"Error with getUserMedia: \" + error.message); // temp: helps when testing for strange issues on ios/safari\n        console.log(error);\n      });\n  };\n\n  setMicGain = newGain => {\n    this.config.micGain = newGain;\n    if (this.audioCtx && this.micGainNode) {\n      this.micGainNode.gain.setValueAtTime(newGain, this.audioCtx.currentTime);\n    }\n  };\n\n  _startRecordingWithStream = (stream, timeslice) => {\n    this.micAudioStream = stream;\n\n    this.inputStreamNode = this.audioCtx.createMediaStreamSource(\n      this.micAudioStream\n    );\n    this.audioCtx = this.inputStreamNode.context;\n\n    // Kind-of a hack to allow hooking in to audioGraph inputStreamNode\n    if (this.onGraphSetupWithInputStream) {\n      this.onGraphSetupWithInputStream(this.inputStreamNode);\n    }\n\n    this.inputStreamNode.connect(this.micGainNode);\n    this.micGainNode.gain.setValueAtTime(\n      this.config.micGain,\n      this.audioCtx.currentTime\n    );\n\n    let nextNode = this.micGainNode;\n    if (this.dynamicsCompressorNode) {\n      this.micGainNode.connect(this.dynamicsCompressorNode);\n      nextNode = this.dynamicsCompressorNode;\n    }\n\n    this.state = \"recording\";\n\n    if (this.processorNode) {\n      nextNode.connect(this.processorNode);\n      this.processorNode.connect(this.outputGainNode);\n      this.processorNode.onaudioprocess = e => this._onAudioProcess(e);\n    } else {\n      nextNode.connect(this.outputGainNode);\n    }\n\n    if (this.analyserNode) {\n      // TODO: If we want the analyser node to receive the processorNode's output, this needs to be changed _and_\n      //       processor node needs to be modified to copy input to output. It currently doesn't because it's not\n      //       needed when doing manual encoding.\n      // this.processorNode.connect(this.analyserNode)\n      nextNode.connect(this.analyserNode);\n    }\n\n    this.outputGainNode.connect(this.destinationNode);\n\n    if (this.config.usingMediaRecorder) {\n      this.mediaRecorder = new MediaRecorder(this.destinationNode.stream);\n      this.mediaRecorder.addEventListener(\"dataavailable\", evt =>\n        this._onDataAvailable(evt)\n      );\n      this.mediaRecorder.addEventListener(\"error\", evt => this._onError(evt));\n\n      this.mediaRecorder.start(timeslice);\n    } else {\n      // Output gain to zero to prevent feedback. Seems to matter only on Edge, though seems like should matter\n      // on iOS too.  Matters on chrome when connecting graph to directly to audioCtx.destination, but we are\n      // not able to do that when using MediaRecorder.\n      this.outputGainNode.gain.setValueAtTime(0, this.audioCtx.currentTime);\n      // this.outputGainNode.gain.value = 0\n\n      // Todo: Note that time slicing with manual wav encoderWav won't work. To allow it would require rewriting the encoderWav\n      // to assemble all chunks at end instead of adding header to each chunk.\n      if (timeslice) {\n        console.log(\n          \"Time slicing without MediaRecorder is not yet supported. The resulting recording will not be playable.\"\n        );\n        this.slicing = setInterval(function() {\n          if (this.state === \"recording\") {\n            this.encoderWorker.postMessage([\"dump\", this.context.sampleRate]);\n          }\n        }, timeslice);\n      }\n    }\n  };\n\n  _onAudioProcess = e => {\n    // console.log('onaudioprocess', e)\n    // let inputBuffer = e.inputBuffer\n    // let outputBuffer = e.outputBuffer\n    // console.log(this.micAudioStream)\n    // console.log(this.audioCtx)\n    // console.log(this.micAudioStream.getTracks().forEach((track) => console.log(track)))\n\n    // this.onAudioEm.dispatch(new Event('onaudioprocess', {inputBuffer:inputBuffer,outputBuffer:outputBuffer}))\n\n    if (this.config.broadcastAudioProcessEvents) {\n      this.em.dispatchEvent(\n        new CustomEvent(\"onaudioprocess\", {\n          detail: {\n            inputBuffer: e.inputBuffer,\n            outputBuffer: e.outputBuffer\n          }\n        })\n      );\n    }\n\n    // // Example handling:\n    // let inputBuffer = e.inputBuffer\n    // let outputBuffer = e.outputBuffer\n    // // Each channel (usually only one)\n    // for (let channel = 0; channel < outputBuffer.numberOfChannels; channel++) {\n    //   let inputData = inputBuffer.getChannelData(channel)\n    //   let outputData = outputBuffer.getChannelData(channel)\n    //\n    //   // Each sample\n    //   for (let sample = 0; sample < inputBuffer.length; sample++) {\n    //     // Make output equal to the same as the input (thus processor is doing nothing at this time)\n    //     outputData[sample] = inputData[sample]\n    //   }\n    // }\n\n    // When manually encoding (safari/edge), there's no reason to copy data to output buffer.  We set the output\n    // gain to 0 anyways (which is required on Edge if we did copy data to output). However, if using a MediaRecorder\n    // and a processor (all other browsers), then it would be required to copy the data otherwise the graph would\n    // generate no data for the MediaRecorder to consume.\n    // if (this.forceScriptProcessor) {\n\n    // // Copy input to output\n    // let inputBuffer = e.inputBuffer\n    // let outputBuffer = e.outputBuffer\n    // // This doesn't work on iOS/Safari. Guessing it doesn't have copyToChannel support, but haven't verified.\n    // for (let channel = 0; channel < outputBuffer.numberOfChannels; channel++) {\n    //   outputBuffer.copyToChannel(inputBuffer.getChannelData(channel), channel)\n    // }\n\n    // Safari and Edge require manual encoding via web worker. Single channel only for now.\n    // Example stereo encoderWav: https://github.com/MicrosoftEdge/Demos/blob/master/microphone/scripts/recorderworker.js\n    if (!this.config.usingMediaRecorder) {\n      if (this.state === \"recording\") {\n        if (this.config.broadcastAudioProcessEvents) {\n          this.encoderWorker.postMessage([\n            \"encode\",\n            e.outputBuffer.getChannelData(0)\n          ]);\n        } else {\n          this.encoderWorker.postMessage([\n            \"encode\",\n            e.inputBuffer.getChannelData(0)\n          ]);\n        }\n      }\n    }\n  };\n\n  stopRecording = () => {\n    if (this.state === \"inactive\") {\n      return;\n    }\n    if (this.config.usingMediaRecorder) {\n      this.state = \"inactive\";\n      this.mediaRecorder.stop();\n    } else {\n      this.state = \"inactive\";\n      this.encoderWorker.postMessage([\"dump\", this.audioCtx.sampleRate]);\n      clearInterval(this.slicing);\n\n      // TODO: There should be a more robust way to handle this\n      // Without something like this, I think  the last recorded sample could be lost due to timing\n      // setTimeout(() => {\n      //   this.state = 'inactive'\n      //   this.encoderWorker.postMessage(['dump', this.audioCtx.sampleRate])\n      // }, 100)\n    }\n  };\n\n  _onDataAvailable = evt => {\n    // console.log('state', this.mediaRecorder.state)\n    // console.log('evt.data', evt.data)\n\n    this.chunks.push(evt.data);\n    this.chunkType = evt.data.type;\n\n    if (this.state !== \"inactive\") {\n      return;\n    }\n\n    let blob = new Blob(this.chunks, { type: this.chunkType });\n    let blobUrl = URL.createObjectURL(blob);\n    const recording = {\n      ts: new Date().getTime(),\n      blobUrl: blobUrl,\n      mimeType: blob.type,\n      size: blob.size\n    };\n\n    this.chunks = [];\n    this.chunkType = null;\n\n    if (this.destinationNode) {\n      this.destinationNode.disconnect();\n      this.destinationNode = null;\n    }\n    if (this.outputGainNode) {\n      this.outputGainNode.disconnect();\n      this.outputGainNode = null;\n    }\n    if (this.analyserNode) {\n      this.analyserNode.disconnect();\n      this.analyserNode = null;\n    }\n    if (this.processorNode) {\n      this.processorNode.disconnect();\n      this.processorNode = null;\n    }\n    if (this.encoderWorker) {\n      this.encoderWorker.postMessage([\"close\"]);\n      this.encoderWorker = null;\n    }\n    if (this.dynamicsCompressorNode) {\n      this.dynamicsCompressorNode.disconnect();\n      this.dynamicsCompressorNode = null;\n    }\n    if (this.micGainNode) {\n      this.micGainNode.disconnect();\n      this.micGainNode = null;\n    }\n    if (this.inputStreamNode) {\n      this.inputStreamNode.disconnect();\n      this.inputStreamNode = null;\n    }\n\n    if (this.config.stopTracksAndCloseCtxWhenFinished) {\n      // This removes the red bar in iOS/Safari\n      this.micAudioStream.getTracks().forEach(track => track.stop());\n      this.micAudioStream = null;\n\n      this.audioCtx.close();\n      this.audioCtx = null;\n    }\n\n    this.em.dispatchEvent(\n      new CustomEvent(\"recording\", { detail: { recording: recording } })\n    );\n  };\n\n  _onError = evt => {\n    console.log(\"error\", evt);\n    this.em.dispatchEvent(new Event(\"error\"));\n    alert(\"error:\" + evt); // for debugging purposes\n  };\n}\n","import React from \"react\";\nimport \"./App.css\";\nimport RecorderService from \"./audio/RecorderService\";\nimport axios from \"axios\";\n\nclass App extends React.Component {\n  state = {\n    url: \"https://localhost:3000\",\n    recordings: []\n  };\n\n  inputRef = React.createRef();\n\n  componentDidMount() {\n    this.recorderSrvc = new RecorderService(\".\");\n    this.recorderSrvc.em.addEventListener(\"recording\", evt =>\n      this.onNewRecording(evt)\n    );\n    this.recorderSrvc.em.addEventListener(\"onaudioprocess\", evt => {\n      this.onAudioProcess(evt);\n    });\n    this.recorderSrvc.config.broadcastAudioProcessEvents = true;\n  }\n\n  startRecording = () => {\n    this.numAudioSamples = 0;\n    this.recorderSrvc\n      .startRecording()\n      .then(() => {\n        this.setState({\n          isRecording: true\n        });\n      })\n      .catch(error => {\n        console.error(\"Exception while start recording: \" + error);\n        alert(\"Exception while start recording: \" + error.message);\n      });\n  };\n\n  stopRecording = () => {\n    this.recorderSrvc.stopRecording();\n    this.setState({\n      isRecording: false\n    });\n  };\n\n  onAudioProcess = e => {\n    this.numAudioSamples++;\n\n    let inputBuffer = e.detail.inputBuffer;\n    let outputBuffer = e.detail.outputBuffer;\n    for (let channel = 0; channel < outputBuffer.numberOfChannels; channel++) {\n      let inputData = inputBuffer.getChannelData(channel);\n      let outputData = outputBuffer.getChannelData(channel);\n      // Each sample\n      for (let sample = 0; sample < inputBuffer.length; sample++) {\n        if (this.addNoise) {\n          outputData[sample] = inputData[sample] + Math.random() * 0.02;\n        } else {\n          outputData[sample] = inputData[sample];\n        }\n      }\n    }\n  };\n\n  onNewRecording = e => {\n    const recordings = this.state.recordings;\n    const newR = e.detail.recording;\n    recordings.push(newR);\n    this.getResponse(newR);\n    this.setState({ recordings });\n  };\n\n  onChangeURL = e => {\n    const url = this.inputRef.current.value;\n    this.setState({ url });\n  };\n\n  getResponse = async recording => {\n    let message;\n    try {\n      const formData = new FormData();\n      console.log(recording);\n      formData.append(\"data\", recording.blobUrl);\n      const res = await axios.post(this.state.url, formData, {\n        headers: {\n          \"Content-Type\": \"multipart/form-data\"\n        }\n      });\n      message = res.data;\n    } catch (e) {\n      message = e.message;\n    }\n    const recordings = this.state.recordings;\n    recordings.find(x => x.blobUrl === recording.blobUrl).responseData = message;\n    this.setState({ recordings });\n  };\n\n  render() {\n    const { recordings, isRecording, url } = this.state;\n    const action = isRecording ? this.stopRecording : this.startRecording;\n    const actionText = isRecording ? \"Stop\" : \"Record\";\n    return (\n      <div className=\"App\">\n        <label>\n          Send to:\n          <input value={url} ref={this.inputRef} onChange={this.onChangeURL} />\n        </label>\n        <br />\n        <button onClick={action}>{actionText}</button>\n        <div className=\"recordings\">\n          {recordings.map(x => {\n            return (\n              <div key={x.blobUrl}>\n                <audio src={x.blobUrl} controls={true} />\n                <p>{x.responseData || \"Retrieving Response...\"}</p>\n              </div>\n            );\n          })}\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.register();"],"sourceRoot":""}